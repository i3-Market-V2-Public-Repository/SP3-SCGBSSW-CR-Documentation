@startuml nonRepudiableExchangeLog
skinparam shadowing false
skinparam DefaultFontName Noto Sans
skinparam DefaultMonospacedFontName Noto Sans Mono
skinparam ArrowFontName Noto Sans Mono
skinparam maxMessageSize 450

title Non-repudiable data-exchange log

box "Consumer" #White
    participant ": SDA SDK" as C
end box
box "Provider" #White
    participant "SDA API\n: Data Transfer Manager" as P
end box
box "i3-Market Backplane\n" #LightGreen
    participant "Backplane API\n: Auditable Accounting" as AA
    participant "Backplane API\n: Conflict Resolution" as CR
end box

C->P++: GET data {id?: <block_id>}
    P->P++: key=new JWK(alg=<algorithm>)
    P--
    note left
        Create random (high entropy)\none time
        symmetric JWK secret. The created JWK 
        MUST be uniquely identified by its ""kid""
    end note
    P->P++: cipherblock=JWE<sub>key</sub>(block)
    P--
    note left
      encrypt data block with ""key"
    end note
    P->P++: PoO=JWS<sub>provider</sub>({\n\
  iss: <provider_id>,\n\
  sub: <consumer_id>,\n\
  iat: <timestamp_now>,\n\
  exchange: {\n\
    id: <exchange_id>,\n\
    orig: <provider_id>,\n\
    dest: <consumer_id>,\n\
    block_id: <block_id>,\n\
    block_desc: <block_description>,\n\
    cipherblock: <cipherblock>,\n\
    block_commitment: <hash_of_block>,\n\
    key_commitment: <hash_of_key>\n\
  }\n\
})
    note left
        Create proof of origin (PoO).

        ""block_desc"" describes the piece of
        plaintext data (format, size, ...)

        ""block_commitment"" is a commitment
        that can be later used to verify the
        decrypted cipherblock

        ""key_commitment"" is a commitment 
        that can be later used to verify the 
        received ""key""
    end note
    P--
return PoO

C->C++: validate PoO
C--

alt invalid PoO
    C->>P !!: terminate
else valid PoO
    C->C: store PoO
    C->C++: PoR=JWS<sub>consumer</sub>({\n\
  iss: <consumer_id>,\n\
  sub: <provider_id>,\n\
  iat: <timestamp_now>,\n\
  poo_dgst: <digest__of_received_PoO>\n\
})
    C--
    note left
      Create proof of reception (PoR)
    end note
    C->P++: PoR
    P->P++: validate PoR
    P--
    alt invalid PoR
        P->>C !!: terminate
    else valid PoR
        P->P: store PoR
        P->AA++: POST account \n\
[\n\
  {\n\
    availability: 'privateStorage',\n\
    permissions: { view: [<providerId>, <consumerId>] },\n\
    type: 'dict',\n\
    id: <PoO.exchange.exchange_id>,\n\
    content: { <block_id>: { PoO: <PoO>, PoR: <PoR> } }\n\
  },\n\
  {\n\
    availability: 'blockchain',\n\
    type: 'jwk',\n\
    content: { <kid>: <key> }\n\
  }\n\
]
        note right
          Proofs for this block are added to the
          stored dict of the current exchange.
          Proofs can only be viewed by the consumer
          and the provider.

          The one-time jwk that was used to encrypt 
          the block is published in the blockchain 
        end note
        return PoP
        note left
          The proof of publication (""PoP"") of ""key"" is a
          verification code that includes blockchain
          specific information proving that the 
          requested data has been accounted (e.g. 
          ""tx_id"", ""block_id"")
        end note
        return { key: <key>, pop: <PoP> }
        opt no response || lost response
            P ->x C: { key: <key>, pop: <PoP> }
            note left
              There is a predefined/agreed 
              max timeout to wait for the 
              ""key"" to be on the blockchain
            end note
            loop while key not received && currentTime < PoR.iat + timeout
                C->AA++: getKey {kid: <kid>}
                note left of AA
                    Although the Consumer can use i3-market to
                    connect to the Blockchain and download the 
                    ""key"", it could also use any other connection to 
                    download it since it is in the public Blockchain
                end note
                return { key: <key>, pop: <PoP> }
            end
        end
        
        C->C++: verify that:\n  key has been received\n  PoP is valid\n  hash(key) == PoO.key_commitment
        C--

        alt validation failed
            C->>P !!: terminate
            opt conflict resolution
                ref over C, P, AA, CR
                    conflict resolution
                end ref
            end
        else validation succeed
            C->C++: decrypt cipherblock with key:\n  decryptedBlock=Dec<sub>key</sub>(PoO.exchange.cipherblock)
            C--
            C->C++: validate that:\n  hash(decryptedBlock) == PoO.exchange.block_commitment\n  decryptedBlock meets PoO.exchange.block_desc
            C--
            opt validation failed
                C->>P !!: terminate
                opt conflict resolution
                    ref over C, P, AA, CR
                        conflict resolution
                    end ref
                end
            end
        end
    end
end
@enduml